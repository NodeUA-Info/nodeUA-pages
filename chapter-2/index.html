<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Асинхронність</title>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body>
    <div class="container">
      <h1>Асинхронність</h1>
      <h2>Багатопотокова модель</h2>
      <p>
        Перед початком занурення в таку цікаву і складну тему, як асинхронність
        в node.js, варто розглянути відмінності асинхронної моделі архітектури
        від більш відомої багатопотокової (наприклад, PHP).
      </p>
      <p>
        При многопоточній моделі додаток створює деяку кількість потоків (пул),
        передаючи кожному з них завдання і дані для обробки, при цьому завдання
        виконуються паралельно. Після завершення роботи потік не видаляється, а
        лежить в пулі, чекаючи наступного завдання.
      </p>
      <p>
        Це прибирає накладні витрати на створення і видалення потоків. Саме за
        такою системою і працює додаток, написаний на PHP. Кожен скрипт працює в
        своєму потоці. Один потік обробляє один запит, при цьому повільні запити
        забирають потік надовго, швидкі - обробляються майже миттєво, звільняючи
        потік для іншої роботи.
      </p>
      <p>
        Це не дозволяє повільним запитам забирати весь процесорний час, змушуючи
        гальмувати швидкі запити. Але у такої системи є певні обмеження. Може
        виникнути ситуація, коли до нас прийде велика кількість повільних
        запитів, наприклад працюючих з БД або файлової системою. Такі запити
        заберуть собі всі потоки, що унеможливить виконання інших запитів. У
        підсумку, є ймовірність отримати досить великий час простою, особливо
        якщо код написаний неграмотно.
      </p>
      <p>
        Краще рішення, яке дозволяє нам повністю завантажити процесор корисною
        роботою - це перехід до архітектури, що використовує неблокуючі
        операції, а саме, до асинхронної архітектурі.
      </p>
      <img src="" alt="Картинка" />
      <h2>Асинхронна модель</h2>
      <p>
        Менш поширена модель, ніж многопоточна, однак вона має не менше
        можливостей. Асинхронна модель побудована на черзі подій (event-loop).
        При виникненні будь-якої події (наприклад, отримання запита, виконання
        зчитування файлу, робота з базою даних) воно поміщається в кінець черги.
      </p>
      <p>
        Потік, який обробляє цю чергу, бере подію з початку черги, і виконує
        пов'язаний з цією подією код. Поки черга не порожня, процесор буде
        зайнятий роботою. За такою схемою працює Node.js. У нас є єдиний потік,
        що обробляє чергу подій (з модулем cluster - потік буде вже не один).
      </p>
      <p>
        Майже всі операції неблокуючі. Блокуючі теж є, але їх використання
        наполегливо не рекомендується, оскільки це не має сенсу, за винятком
        вкрай рідкісних ситуацій, які виникають не у всіх проектах і не у всіх
        розробників.
      </p>
      <p>
        Повернемося до неблокуючих операцій - при їх використанні процесор
        завжди буде зайнятий корисною роботою. Варто врахувати, що асинхронні
        системи з неблокуючими операціями повинні мати не більше потоків, аніж
        кількість ядер в системі.
      </p>
      <img src="" alt="Картинка2" />
      <p>
        У момент, коли сервер отримує запит, якщо в черзі нічого не було, то цей
        запит відразу виконується, наприклад, при запиті будь-якого файлу на
        клієнт буде повернутий відповідний файл. Якщо ж в черзі щось є -
        доведеться почекати обробку інших подій. Зазвичай швидкість обробки
        одного запиту буде порівнянна зі швидкістю обробки багатопотоковою
        системою і блокуючими операціями.
      </p>
      <p>
        У гіршому випадку - на очікування обробки інших подій буде витрачено
        час, і запит буде опрацьовано повільніше. При цьому на обробку черги і
        перехід від події до події витрачається набагато менше часу, аніж на
        перемикання між потоками у багатопотоковій системі.
      </p>
      <p>
        Підводячи підсумок, не можна сказати, що багатопотокова модель краще
        асинхронної, як і навпаки. Застосування тієї чи іншої моделі може бути
        більш виправдано в залежності від специфіки характеру поставленого
        завдання.
      </p>
      <h2>EventLoop</h2>
      <p>
        Цикл подій (Event Loop) - це те, що дозволяє Node.js виконувати
        неблокуючі операції введення / виводу (незважаючи на те, що JavaScript є
        однопоточним) шляхом вивантаження операцій в ядро системи, коли це
        можливо.
      </p>
      <p>
        Коли Node.js запускається, вона ініціалізує цикл подій, обробляє наданий
        на вхід код, який може виконувати виклики асинхронного API,
        налаштовувати таймери або викликати process.nextTick ().
      </p>
      <p>
        Потім починається обробка циклу подій. Loop перекладається з
        англійської, як петля, і обробка циклу подій в node.js дійсно схожа на
        петлю, на замкнуте коло, який повторюється з разу в раз. На кожному колі
        є одні й ті ж "фази", які обробляються node.js послідовно і мають власні
        функції зворотного виклику.
      </p>
      <p>
        Хоча кожна фаза є по-своєму особливою, зазвичай, коли цикл подій входить
        в дану фазу, вона буде виконувати будь-які операції, що відносяться до
        цієї фази, а потім виконувати функції зворотного виклику в черзі цієї
        фази, поки черга не буде вичерпана, або максимальну кількість функцій
        зворотного виклику не буде оброблено.
      </p>
      <p>
        Коли черга вичерпана або досягнута межа функції зворотного виклику, цикл
        подій переміститься на наступну фазу і так далі.
      </p>
      <img src="" alt="Картинка3" />
      <p>Зупинимося трохи докладніше на кожній фазі:</p>
      <ul>
        <li>
          Таймери - виконання функцій зворотного виклику, заплановані викликами
          setTimeout () і setInterval ();
        </li>
        <li>
          I/O коллбеки - виконання практично всіх функцій зворотного виклику, за
          винятком подій таймерів (були виконані раніше), close і setImmediate
          () (будуть виконані далі);
        </li>
        <li>
          очікування, підготовка: використовується тільки для внутрішніх потреб;
        </li>
        <li>
          опитування: отримання і реєстрація нових подій I/O. Node.js може
          блокуватися на цьому етапі;
        </li>
        <li>
          перевірка: функції зворотного виклику, ініційовані викликом
          setImmediate (), викликаються на цьому етапі;
        </li>
        <li>
          функції зворотного виклику події close: наприклад, socket.on (
          'close', ...);
        </li>
      </ul>
      <p>
        Між кожною итерацією циклу подій Node.js перевіряє, чи очікується
        завершення будь-яких асинхронних операцій введення / виводу або
        таймерів, і завершує роботу, якщо їх немає.
      </p>
      <h2>EventEmmiter</h2>
      <p>
        Переважна більшість функціоналу Node.js застосовує асинхронну
        подійно-орієнтовану архітектуру, яка використовує спеціальні об'єкти -
        емітери для генерації різних подій, які обробляються спеціальними
        функціями - обработчиками або слухачами подій. Всі об'єкти, які
        генерують події, представляють екземпляри класу EventEmitter.
      </p>
      <p>
        За допомогою функції eventEmitter.on() до певної події на ім'я
        чіпляється функція обробника. Причому для однієї події можна вказати
        безліч обробників. Коли об'єкт EventEmitter генерує подію, відбувається
        виконання всіх цих обробників.
      </p>
      <p>
        Весь необхідний функціонал зосереджений в модулі events, який необхідно
        підключити (тільки підключити, окремо встановлювати його за допомогою
        npm або yarn не потрібно). За допомогою функції on() зв'язуємо подію,
        яка передається в якості першого параметра, з деякою функцією, яка
        передається в якості другого параметра. В даному випадку подія
        називається "greet".
      </p>
      <p>
        Для генерації події і виклику пов'язаних з ним оброблювачів виконується
        функція eventEmitter.emit(), в яку передається назва події. І під час
        запуску програми будуть викликані всі обробники.
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        ><span style="color: #008800; font-weight: bold">const</span> Events = require(<span style="color: #dd2200; background-color: #fff0f0">&quot;events&quot;</span>);
	<span style="color: #008800; font-weight: bold">const</span> eventEmitter = <span style="color: #008800; font-weight: bold">new</span> Events ();

	eventEmitter.on(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>, () =&gt; {
    		console.log(<span style="color: #dd2200; background-color: #fff0f0">&quot;Hello, world!&quot;</span>);
	});
 
	eventEmitter.on(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_disconnected&#39;</span>, () =&gt; {
   		console.log(<span style="color: #dd2200; background-color: #fff0f0">&quot;GoodBye!&quot;</span>);
	});
 
	eventEmitter.emit(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>);
eventEmitter.emit(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_disconnected&#39;</span>);
</pre>
      </div>
      <p>
        Ви також можете передавати в оброблювачі подій власні аргументи.
        Результат виконання цього коду буде аналогічний попередньому прикладу
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        ><span style="color: #008800; font-weight: bold">const</span> Events = require(<span style="color: #dd2200; background-color: #fff0f0">&quot;events&quot;</span>);
	<span style="color: #008800; font-weight: bold">const</span> eventEmitter = <span style="color: #008800; font-weight: bold">new</span> Events ();

	eventEmitter.on(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>, (string) =&gt; {
    		console.log(string);
	});
 
	eventEmitter.on(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_disconnected&#39;</span>, (string) =&gt; {
   		console.log(string);
	});
 
	eventEmitter.emit(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>, <span style="color: #dd2200; background-color: #fff0f0">&quot;Hello, world!&quot;</span>);
eventEmitter.emit(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_disconnected&#39;</span>, <span style="color: #dd2200; background-color: #fff0f0">&quot;GoodBye!&quot;</span>);
</pre>
      </div>
      <p>
        Крім звичайного призначення обробника події, також можна видалити
        призначений раніше обробник (при цьому буде видалена лише передана
        функція - обробник, всі інші обробники, призначені раніше на цю ж подію
        функціонуватимуть);
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        ><span style="color: #008800; font-weight: bold">let</span> callback = () =&gt; {
  console.log(<span style="color: #dd2200; background-color: #fff0f0">&quot;Hello, world!&quot;</span>);
};
eventEmitter .on(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>, callback);
eventEmitter.removeListener(<span style="color: #dd2200; background-color: #fff0f0">&#39;user_connected&#39;</span>, callback );
</pre>
      </div>
      <p>
        Але і це далеко не весь функціонал класу EventEmmiter. Крім
        вищеописаного, у нього ще є ряд цікавих можливостей, наприклад,
        призначити обробник, який буде виконаний тільки один раз, видалити
        відразу всі обробники конкретної події або призначити максимальне число
        обробників для конкретної події.
      </p>
      <p>
        За більш детальною інформацією зверніться до офіційної документації
        node.js
        <a href="https://nodejs.org/api/events.html"
          >(https://nodejs.org/api/events.html)</a
        >.
      </p>
      <h2>Функції зворотного виклику</h2>
      <p>
        Node.js підтримує кілька способів написання асинхронного коду. Найбільш
        простим і тим, що часто зустрічається, є "Стиль передачі продовження"
        (Continuation Passing Style, CPS), при якому логіка роботи асинхронного
        коду будується на функціях зворотного виклику, коли розробник визначає
        функцію, яка повинна бути викликана тільки після завершення попередньої
        функції.
      </p>
      <p>
        Функція зворотного виклику (або коллбек, callback) - загальноприйнята
        назва для функції в node.js. Це не особлива функція, яка називається
        «зворотний виклик», а угода. Замість того, щоб відразу ж повернути
        якийсь результат, як робить більшість функцій, ці, що використовують
        зворотні виклики функції, вимагають час для отримання результату. Слово
        «асинхронний» або «async» означає, що воно «займає якийсь час» або
        «трапиться в майбутньому, не зараз». Зворотні виклики використовуються
        не тільки при виконанні введення-виведення (I / O - введення-виведення),
        наприклад, при завантаженні, зчитуванні файлів, обміні інформації з
        базами даних і так далі, але і, наприклад, при використанні таймерів.
      </p>
      <p>
        Функції зворотного виклику хороші тим, що допомагають розробнику
        здійснити в його коді подійно-орієнтованість і асинхронність, миттєво
        реагувати на події, що відбулися, і, як ми вже побачили вище, на відміну
        від багатопотокової архітектури, проробляти велику роботу в одному
        процесі і економити ресурси. Але у них є і дуже серйозні мінуси - з
        ростом складності, код зростає і швидко перетворюється в малозрозумілий
        код, який важко читати.
      </p>
      <p>
        Давайте уявимо, що у нас є функція getData, яка приймає абстрактний
        об'єкт і додає в нього якісь дані (наприклад, об'єкт з інформацією про
        користувача, в який потрібно додати з бази даних дозволи на сервіси,
        додаткову інформацію, тощо.
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        >getData(<span style="color: #008800; font-weight: bold">function</span>(a){  
	getMoreDataOne(a, <span style="color: #008800; font-weight: bold">function</span>(b){
    getMoreDataTwo(b, <span style="color: #008800; font-weight: bold">function</span>(c){ 
          getMoreDataThree(c, <span style="color: #008800; font-weight: bold">function</span>(d){ 
                getMoreDataFour(d, <span style="color: #008800; font-weight: bold">function</span>(e){ 
                 <span style="color: #888888">// і так далі</span>
              });
          });
     });
});
});
</pre>
      </div>

      <p>
        Це дуже поганий код, не тільки тому що він складно читається, але і
        тому, що при виконанні він може бути небезпечний. Наприклад, якщо в
        одній з функцій буде виконуватися цикл «for», який запустить безліч
        запитів в базу даних миттєво, або якщо в цьому циклі буде дуже багато
        об'єктів, то ваш сервер зависне і/або впаде з помилкою і виконання
        програми буде перервано.
      </p>
      <p>
        З цим можна боротися шляхом переписування циклу «for» в рекурсивну
        функцію з колбеком, але рекурсія може переповнити стек і також призведе
        до проблем з движком. Крім того, рекурсивні програми важче для
        розуміння. Так само можна оголосити всі функції за допомогою синтаксису
        Function Expression, в контексті будь-якого виразу, наприклад
        присвоювання, але це не вирішить більшість проблем, крім поліпшення
        читання.
      </p>
      <p>
        На щастя, в JavaScript є вбудовані можливості для вирішення цих проблем.
      </p>
      <h2>Promises</h2>
      <p>
        Найімовірніше, ви вже знайомі з обіцянками в JavaScript, якщо ні,
        скористайтеся посиланням
        <a href="https://learn.javascript.ru/promise"
          >https://learn.javascript.ru/promise</a
        >. Висловлюючись простою мовою, об'єкт Promise є абстракцією, що
        дозволяє функцій повертати об'єкт Promise, який представляє кінцевий
        результат асинхронної операції.
      </p>
      <p>
        Ми говоримо, що об'єкт Promise очікує, якщо асинхронна операція ще не
        завершилася, виконаний - якщо операція завершилася успішно, і відхилений
        - якщо виникла помилка. Після того як об'єкт Promise буде виконаний або
        відхилений, він вважається вирішеним. Якщо переписати попередню умову з
        використанням Promises, попередньо оголосивши і описавши функції, то код
        стане краще, до того ж стане зручніше перехоплювати помилки.
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre style="margin: 0; line-height: 125%">getData()
.then(getMoreDataOne)
.then(getMoreDataTwo)
.then(getMoreDataThree)
.then(getMoreDataFour)
.<span style="color: #008800; font-weight: bold">catch</span>(error) {
	console.log(error);
};
</pre>
      </div>
      <p>Так вже набагато краще, але є і більш сучасний і лаконічний спосіб.</p>
      <h2>Async/Await</h2>
      <p>
        У Node.js, починаючи з версії 7.6, вбудована підтримка механізму async /
        await. Кажуть про нього, звичайно, вже давно, але одна справа коли для
        використання якоїсь функціональності потрібні «милиці», і зовсім інша,
        коли все це йде, що називається, «з коробки». Якщо ви ще не пробували
        async / await - обов'язково спробуйте.
      </p>
      <p>
        Для тих, хто не знайомий з async / await, ось основні речі, які корисно
        буде знати перш ніж рухатися далі.
      </p>
      <p>
        Async / await - це новий спосіб написання асинхронного коду. Раніше
        подібний код писали, користуючись функціями зворотного виклику і
        Promises. Пропозиція «забути про Promises» не означає, що вони втратили
        актуальності у світлі нової технології. Насправді, в основі async /
        await лежать Проміс. Потрібно враховувати, що цей механізм не можна
        використовувати з функціями зворотного виклику. Конструкції, побудовані
        з використанням async / await, як і Promises, не блокують головний потік
        виконання програми.
      </p>
      <p>
        Завдяки async / await, асинхронний код стає схожим на синхронний, так і
        в його поведінці з'являються риси такого коду, вельми корисні в деяких
        ситуаціях, в яких Promises користуватися було, з різних причин,
        незручно. Але раніше без них було не обійтися. Тепер все змінилося. Саме
        тут криється могутність async / await. Просто подивіться на реалізацію
        попереднього прикладу.
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        ><span style="color: #008800; font-weight: bold">let</span> getData = async () =&gt; {
  await getMoreDataOne();
  await getMoreDataTwo();
  await getMoreDataThree();
  await getMoreDataFour();
};
</pre>
      </div>
      <p>
        Обробка помилок в коді, написаному з використанням async / await так
        само зручна і проста.
      </p>
      <div
        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"
      >
        <pre
          style="margin: 0; line-height: 125%"
        ><span style="color: #008800; font-weight: bold">let</span> getData = async () =&gt; {
	<span style="color: #008800; font-weight: bold">try</span> {
    await getMoreDataOne();
    await getMoreDataTwo();
    await getMoreDataThree();
    await getMoreDataFour();
  } <span style="color: #008800; font-weight: bold">catch</span> (error) {
    console.log(error);
  }
};
</pre>
      </div>
      <p>
        Причому, на перший погляд, особливої відмінності від Promises немає, але
        вже при перехопленні першої ж помилки ви побачите серйозну різницю -
        стек помилки, що повертається з ланцюжка Promises, не містить вказівки
        на те, де саме сталася помилка. Більш того, повідомлення про помилку
        здатне спрямувати зусилля з пошуку проблеми хибним шляхом.
      </p>
      <p>
        Якщо ж поглянути на подібну ситуацію при використанні async / await,
        стек помилки вкаже на ту функцію, в якій виникла проблема.
      </p>
      <p>
        Мабуть, async / await - це одна з найкорисніших революційних
        можливостей, доданих в JavaScript в останні кілька років. Вона дає
        прості і зручні способи написання і налагодження асинхронного коду.
      </p>
    </div>
  </body>
</html>
